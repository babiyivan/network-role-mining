# Finding structural equivalent classes with Euclidean distance

```{r}
libs <- c(
     "sna",
     "igraph",
     "dplyr"
)
new.packages <- libs[!(libs %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
invisible(lapply(libs, library, character.only = TRUE))
```


```{r}
types = c('votes', 'replies', 'follows')
gs = list()
Ms = list()
```


```{r}
n = 253
for (t in types) {
  gs[[t]] = read_graph(paste0('graphs/',t,'-',n,'.graphml'), format = 'graphml')
  Ms[[t]] = as_adjacency_matrix(gs[[t]], sparse = FALSE)
}
```

To run the algorithm on the full graph:

```{r}
# els = list()
# els[['votes']] = read_parquet("data/df_edge_list_directed_users_votes_to_postings_net.parquet") %>%
#   rename(weight = count_votes_to_postings_net)
# els[['replies']] <- read_parquet("data/df_edge_list_directed_users_postings_replies.parquet") %>%
#     rename(weight = count_posting_replies)
# els[['follows']] = read_parquet('data/df_edge_list_directed_users_combined_postings_replies_and_votes_to_postings_net_and_follow_connections.parquet')
# follows = follows %>% filter(count_follow_connection > 0) %>%
#   rename(weight = count_follow_connection)

# gs = list()
# Ms = list()
# for (t in types) {
#      gs[[t]] = graph_from_data_frame(els[[t]], directed = TRUE)
#      Ms[[t]] = as_adjacency_matrix(gs[[t]], sparse = FALSE)
# }
```

Run the algorithm and export the results.

```{r}
eq = list()
for (t in types) {
     eq[[t]]$cluster = equiv.clust(Ms[[t]], method="euclidean", 
          mode="digraph", 
          cluster.method="complete"
     )
     eq[[t]]$dist = sedist(Ms[[t]], method="euclidean", mode="digraph")
     saveRDS(eq[[t]], file=paste0('results/structural/struct-', n, '-', t, '.rds'))
} 
```

Plot the clusters as a dendrogram.

```{r}
for (t in types) {
     plot(eq[[t]]$cluster, labels=eq[[t]]$glabels)
}
```

Visualise the graph with the clusters.

```{r}
for (t in types) {
     plot(gs[[t]], layout = layout_with_fr(gs[[t]]),
          vertex.frame.width=0, vertex.color = cutree(eq[[t]]$cluster, 3), vertex.size=5, edge.arrow.size=0.2)
}
```